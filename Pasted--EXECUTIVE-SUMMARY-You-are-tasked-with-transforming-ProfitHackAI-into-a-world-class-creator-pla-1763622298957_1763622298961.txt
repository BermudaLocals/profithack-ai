## EXECUTIVE SUMMARY

You are tasked with transforming ProfitHackAI into a world-class creator platform with three major enhancements:

1. **TikTok-Style Startup & Feed Experience** - Smooth onboarding with auto-play video feed
2. **100+ Futuristic Sparks System** - Advanced gift system with animations and audio effects
3. **Advanced AI Cloning Technology** - Voice synthesis, face generation, and video deepfakes (100x better than existing solutions)

This prompt provides complete implementation specifications, code examples, database schemas, and deployment instructions.

---

# SECTION 1: TIKTOK-STYLE STARTUP & FEED EXPERIENCE

## 1.1 Startup Flow Architecture

The startup experience follows this sequence:

**Splash Screen (0-2 seconds)** → **Auth Check (2-4 seconds)** → **Login Modal (4-6 seconds)** → **Feed Skeleton (6-8 seconds)** → **Auto-Play Feed (8+ seconds)**

### 1.1.1 SplashScreen Component

Create `client/src/components/SplashScreen.tsx`:

```typescript
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'wouter';
import './SplashScreen.css';

export const SplashScreen: React.FC = () => {
  const navigate = useNavigate();
  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null);
  const [fadeOut, setFadeOut] = useState(false);

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const response = await fetch('/api/auth/me', { credentials: 'include' });
        if (response.ok) {
          setIsAuthenticated(true);
          setTimeout(() => {
            setFadeOut(true);
            setTimeout(() => navigate('/'), 500);
          }, 2000);
        } else {
          setIsAuthenticated(false);
          setTimeout(() => {
            setFadeOut(true);
            setTimeout(() => navigate('/login'), 500);
          }, 2000);
        }
      } catch (error) {
        console.error('Auth check failed:', error);
        setIsAuthenticated(false);
        setTimeout(() => {
          setFadeOut(true);
          setTimeout(() => navigate('/login'), 500);
        }, 2000);
      }
    };

    checkAuth();
  }, [navigate]);

  return (
    <div className={`splash-screen ${fadeOut ? 'fade-out' : ''}`}>
      <div className="splash-background">
        <div className="gradient-blob blob-1"></div>
        <div className="gradient-blob blob-2"></div>
        <div className="gradient-blob blob-3"></div>
      </div>

      <div className="splash-content">
        <div className="logo-container">
          <div className="logo-pulse">
            <svg width="120" height="120" viewBox="0 0 120 120" fill="none">
              <circle cx="60" cy="60" r="55" stroke="currentColor" strokeWidth="2" fill="none" />
              <text x="60" y="70" textAnchor="middle" fontSize="24" fontWeight="bold" fill="currentColor">
                PHA
              </text>
            </svg>
          </div>
        </div>

        <h1 className="splash-title">ProfitHackAI</h1>
        <p className="splash-subtitle">Create. Monetize. Dominate.</p>

        <div className="loading-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
    </div>
  );
};
```

### 1.1.2 SplashScreen Styling

Create `client/src/components/SplashScreen.css`:

```css
.splash-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  overflow: hidden;
  transition: opacity 0.5s ease-out;
}

.splash-screen.fade-out {
  opacity: 0;
  pointer-events: none;
}

.splash-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #0a1e3f 0%, #0d2a5f 50%, #1a3a7a 100%);
  overflow: hidden;
}

.gradient-blob {
  position: absolute;
  border-radius: 50%;
  filter: blur(80px);
  opacity: 0.3;
  animation: float 8s ease-in-out infinite;
}

.blob-1 {
  width: 300px;
  height: 300px;
  background: #00d4ff;
  top: -100px;
  left: -100px;
  animation-delay: 0s;
}

.blob-2 {
  width: 250px;
  height: 250px;
  background: #8b5cf6;
  bottom: -50px;
  right: -50px;
  animation-delay: 2s;
}

.blob-3 {
  width: 200px;
  height: 200px;
  background: #10b981;
  top: 50%;
  right: 10%;
  animation-delay: 4s;
}

@keyframes float {
  0%, 100% { transform: translate(0, 0); }
  50% { transform: translate(20px, -20px); }
}

.splash-content {
  position: relative;
  z-index: 10;
  text-align: center;
  color: white;
}

.logo-container {
  margin-bottom: 30px;
}

.logo-pulse {
  display: inline-block;
  animation: pulse-scale 2s ease-in-out infinite;
  color: #00d4ff;
}

@keyframes pulse-scale {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.8; }
}

.splash-title {
  font-size: 48px;
  font-weight: 700;
  margin: 0;
  letter-spacing: 2px;
  background: linear-gradient(135deg, #00d4ff 0%, #8b5cf6 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.splash-subtitle {
  font-size: 18px;
  color: #b8c5d6;
  margin: 10px 0 30px;
  font-weight: 300;
  letter-spacing: 1px;
}

.loading-dots {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-top: 30px;
}

.loading-dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #00d4ff;
  animation: bounce 1.4s infinite;
}

.loading-dots span:nth-child(2) { animation-delay: 0.2s; }
.loading-dots span:nth-child(3) { animation-delay: 0.4s; }

@keyframes bounce {
  0%, 80%, 100% { transform: scale(1); opacity: 0.5; }
  40% { transform: scale(1.2); opacity: 1; }
}
```

### 1.1.3 Auto-Play Feed Component

Update `client/src/pages/Feed.tsx`:

```typescript
import React, { useEffect, useRef, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { FeedSkeleton } from '../components/FeedSkeleton';

interface Video {
  id: string;
  title: string;
  videoUrl: string;
  creatorId: string;
  creatorUsername: string;
  creatorAvatar: string;
  views: number;
  likes: number;
}

export const Feed: React.FC = () => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [videos, setVideos] = useState<Video[]>([]);
  const videoRefs = useRef<(HTMLVideoElement | null)[]>([]);
  const containerRef = useRef<HTMLDivElement>(null);

  const { data, isLoading } = useQuery({
    queryKey: ['videos', 'feed'],
    queryFn: async () => {
      const response = await fetch('/api/videos/reels');
      return response.json();
    },
  });

  useEffect(() => {
    if (data?.videos) {
      setVideos(data.videos);
    }
  }, [data]);

  // Auto-play current video
  useEffect(() => {
    const currentVideo = videoRefs.current[currentIndex];
    if (currentVideo) {
      currentVideo.play().catch((error) => {
        console.log('Auto-play prevented:', error);
      });
    }

    // Pause other videos
    videoRefs.current.forEach((video, index) => {
      if (index !== currentIndex && video) {
        video.pause();
      }
    });
  }, [currentIndex]);

  // Handle vertical scroll
  useEffect(() => {
    const handleWheel = (e: WheelEvent) => {
      e.preventDefault();
      if (e.deltaY > 0) {
        setCurrentIndex((prev) => Math.min(prev + 1, videos.length - 1));
      } else {
        setCurrentIndex((prev) => Math.max(prev - 1, 0));
      }
    };

    const container = containerRef.current;
    if (container) {
      container.addEventListener('wheel', handleWheel, { passive: false });
      return () => container.removeEventListener('wheel', handleWheel);
    }
  }, [videos.length]);

  // Handle touch swipe
  const handleTouchStart = useRef(0);
  const handleTouchEnd = (e: React.TouchEvent) => {
    const touchEnd = e.changedTouches[0].clientY;
    const diff = handleTouchStart.current - touchEnd;

    if (Math.abs(diff) > 50) {
      if (diff > 0) {
        setCurrentIndex((prev) => Math.min(prev + 1, videos.length - 1));
      } else {
        setCurrentIndex((prev) => Math.max(prev - 1, 0));
      }
    }
  };

  if (isLoading) {
    return <FeedSkeleton />;
  }

  return (
    <div
      ref={containerRef}
      className="feed-container"
      onTouchStart={(e) => (handleTouchStart.current = e.touches[0].clientY)}
      onTouchEnd={handleTouchEnd}
    >
      {videos.map((video, index) => (
        <div
          key={video.id}
          className={`feed-video-card ${index === currentIndex ? 'active' : ''}`}
          style={{
            transform: `translateY(${(index - currentIndex) * 100}vh)`,
            transition: 'transform 0.3s ease-out',
          }}
        >
          <video
            ref={(el) => (videoRefs.current[index] = el)}
            src={video.videoUrl}
            className="feed-video"
            loop
            muted={index !== currentIndex}
            playsInline
          />

          <div className="video-overlay">
            <div className="video-sidebar">
              {/* Creator info, like button, gift button, etc. */}
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};
```

---

# SECTION 2: 100+ FUTURISTIC SPARKS SYSTEM

## 2.1 Database Schema for Sparks

Update `shared/schema.ts`:

```typescript
import {
  pgTable,
  serial,
  text,
  integer,
  boolean,
  timestamp,
  jsonb,
  decimal,
  varchar,
  index,
  uniqueIndex,
} from 'drizzle-orm/pg-core';

export const sparks = pgTable(
  'sparks',
  {
    id: serial('id').primaryKey(),
    name: varchar('name', { length: 100 }).notNull().unique(),
    emoji: varchar('emoji', { length: 10 }).notNull(),
    description: text('description'),
    slug: varchar('slug', { length: 100 }).notNull().unique(),
    category: varchar('category', { length: 50 }).notNull(),
    subcategory: varchar('subcategory', { length: 50 }),
    creditCost: integer('credit_cost').notNull(),
    usdValue: decimal('usd_value', { precision: 8, scale: 2 }),
    rarity: varchar('rarity', { length: 20 }).default('common'),
    animationType: varchar('animation_type', { length: 50 }).notNull(),
    animationDuration: integer('animation_duration').notNull(),
    particleCount: integer('particle_count').default(50),
    scale: integer('scale').default(100),
    primaryColor: varchar('primary_color', { length: 7 }).notNull(),
    secondaryColor: varchar('secondary_color', { length: 7 }),
    tertiaryColor: varchar('tertiary_color', { length: 7 }),
    soundEffectId: integer('sound_effect_id'),
    soundVolume: integer('sound_volume').default(70),
    hasAudio: boolean('has_audio').default(false),
    isActive: boolean('is_active').default(true),
    isNew: boolean('is_new').default(false),
    isFeatured: boolean('is_featured').default(false),
    isLimited: boolean('is_limited').default(false),
    availableFrom: timestamp('available_from'),
    availableUntil: timestamp('available_until'),
    totalSent: integer('total_sent').default(0),
    totalRevenue: decimal('total_revenue', { precision: 12, scale: 2 }).default('0'),
    popularity: integer('popularity').default(0),
    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
    metadata: jsonb('metadata'),
  },
  (table) => ({
    categoryIdx: index('sparks_category_idx').on(table.category),
    isNewIdx: index('sparks_is_new_idx').on(table.isNew),
    creditCostIdx: index('sparks_credit_cost_idx').on(table.creditCost),
    isActiveIdx: index('sparks_is_active_idx').on(table.isActive),
    rarityIdx: index('sparks_rarity_idx').on(table.rarity),
    nameUnique: uniqueIndex('sparks_name_unique').on(table.name),
    slugUnique: uniqueIndex('sparks_slug_unique').on(table.slug),
  })
);

export const sparkAnimationConfigs = pgTable(
  'spark_animation_configs',
  {
    id: serial('id').primaryKey(),
    sparkId: integer('spark_id').notNull().references(() => sparks.id),
    easing: varchar('easing', { length: 50 }).notNull().default('ease-out'),
    duration: integer('duration').notNull(),
    startX: integer('start_x').default(0),
    startY: integer('start_y').default(0),
    endX: integer('end_x').default(0),
    endY: integer('end_y').default(0),
    rotationStart: integer('rotation_start').default(0),
    rotationEnd: integer('rotation_end').default(360),
    scaleStart: integer('scale_start').default(100),
    scaleEnd: integer('scale_end').default(100),
    opacityStart: integer('opacity_start').default(100),
    opacityEnd: integer('opacity_end').default(100),
    pathType: varchar('path_type', { length: 50 }).default('linear'),
    pathData: jsonb('path_data'),
    particleVelocity: integer('particle_velocity').default(2),
    particleGravity: decimal('particle_gravity', { precision: 3, scale: 2 }).default('0.1'),
    particleSpread: integer('particle_spread').default(360),
    colorTransition: boolean('color_transition').default(false),
    colorStops: jsonb('color_stops'),
    glowIntensity: integer('glow_intensity').default(0),
    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
  }
);

export const virtualGifts = pgTable(
  'virtual_gifts',
  {
    id: serial('id').primaryKey(),
    senderId: integer('sender_id').notNull().references(() => users.id),
    recipientId: integer('recipient_id').notNull().references(() => users.id),
    sparkId: integer('spark_id').notNull().references(() => sparks.id),
    creditsCost: integer('credits_cost').notNull(),
    creatorShare: decimal('creator_share', { precision: 10, scale: 2 }).notNull(),
    platformShare: decimal('platform_share', { precision: 10, scale: 2 }).notNull(),
    videoId: integer('video_id').references(() => videos.id),
    message: text('message'),
    isAnonymous: boolean('is_anonymous').default(false),
    status: varchar('status', { length: 20 }).default('completed'),
    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => ({
    senderIdx: index('virtual_gifts_sender_idx').on(table.senderId),
    recipientIdx: index('virtual_gifts_recipient_idx').on(table.recipientId),
    sparkIdx: index('virtual_gifts_spark_idx').on(table.sparkId),
  })
);
```

## 2.2 SparkAnimation Component

Create `client/src/components/SparkAnimation.tsx`:

```typescript
import React, { useEffect, useRef } from 'react';
import './SparkAnimation.css';

interface SparkConfig {
  id: string;
  name: string;
  emoji: string;
  animationType: string;
  animationDuration: number;
  soundEffect?: string;
  particleCount: number;
  color: string;
  scale: number;
}

interface SparkAnimationProps {
  spark: SparkConfig;
  x: number;
  y: number;
  onComplete: () => void;
}

export const SparkAnimation: React.FC<SparkAnimationProps> = ({ spark, x, y, onComplete }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const audioRef = useRef<HTMLAudioElement | null>(null);

  useEffect(() => {
    if (spark.soundEffect) {
      audioRef.current = new Audio(spark.soundEffect);
      audioRef.current.volume = 0.7;
      audioRef.current.play().catch((error) => {
        console.log('Audio playback failed:', error);
      });
    }

    if (containerRef.current) {
      createParticles(spark, containerRef.current);
    }

    const timer = setTimeout(() => {
      onComplete();
    }, spark.animationDuration);

    return () => {
      clearTimeout(timer);
      if (audioRef.current) {
        audioRef.current.pause();
      }
    };
  }, [spark, onComplete]);

  const createParticles = (spark: SparkConfig, container: HTMLDivElement) => {
    const particleCount = spark.particleCount;

    for (let i = 0; i < particleCount; i++) {
      const particle = document.createElement('div');
      particle.className = 'spark-particle';

      const angle = (Math.PI * 2 * i) / particleCount;
      const velocity = 2 + Math.random() * 4;
      const vx = Math.cos(angle) * velocity;
      const vy = Math.sin(angle) * velocity;

      particle.style.left = '0';
      particle.s
(Content truncated due to size limit. Use page ranges or line ranges to read remaining content)