ProfitHackAI: Video Ads System - Complete Deployment Guide

Overview

This guide provides step-by-step instructions for deploying the complete video ads system with 8 new database tables to your ProfitHackAI production environment.

Total Tables: 8
Total Indexes: 45+
Total Views: 4
Total Stored Procedures: 2
Total Triggers: 8
Estimated Deployment Time: 15-30 minutes




Prerequisites

•
PostgreSQL 12+ database

•
Drizzle ORM configured

•
Node.js 18+ runtime

•
Database backup (CRITICAL)

•
Replit project access




Step 1: Backup Your Database

CRITICAL: Always backup before running migrations

Bash


# Create a backup of your current database
pg_dump -U postgres -d profithackai -f profithackai_backup_$(date +%Y%m%d_%H%M%S).sql

# Or if using Replit with Neon:
# Use the Neon dashboard to create a branch or backup





Step 2: Copy Migration Files

Option A: Using SQL Migration Script

1.
Copy the entire contents of VIDEO_ADS_MIGRATION_COMPLETE.sql

2.
In your Replit project, create a new file: migrations/007_video_ads_system.sql

3.
Paste the SQL script into this file

Option B: Using Drizzle ORM

1.
Copy the contents of VIDEO_ADS_DRIZZLE_SCHEMA.ts

2.
Add to your shared/schema.ts file (after existing tables)

3.
Run Drizzle migration: npm run db:push




Step 3: Execute the Migration

Method 1: Direct SQL Execution (Recommended for Replit)

Bash


# In your Replit terminal:
psql $DATABASE_URL < migrations/007_video_ads_system.sql

# Or using Node.js:
node -e "
  const fs = require('fs');
  const sql = fs.readFileSync('migrations/007_video_ads_system.sql', 'utf8');
  const { db } = require('./server/storage');
  db.exec(sql).then(() => console.log('Migration complete'));
"


Method 2: Using Drizzle Migrate

Bash


# If using Drizzle migrations:
npm run db:migrate

# Or manually:
drizzle-kit migrate


Method 3: Using psql CLI

Bash


# Connect to your database and run the migration
psql -h your-db-host -U your-db-user -d your-db-name -f VIDEO_ADS_MIGRATION_COMPLETE.sql

# Enter password when prompted





Step 4: Verify Migration Success

Run these verification queries to confirm all tables were created:

SQL


-- Check if all 8 tables exist
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name IN (
  'video_ad_campaigns',
  'video_ad_creatives',
  'ai_clones',
  'video_ad_placements',
  'video_ad_metrics',
  'advertiser_discovery_records',
  'creator_video_ad_earnings',
  'ad_generation_jobs'
)
ORDER BY table_name;

-- Expected output: 8 rows

-- Check indexes
SELECT COUNT(*) as total_indexes
FROM pg_indexes
WHERE schemaname = 'public'
AND tablename IN (
  'video_ad_campaigns',
  'video_ad_creatives',
  'ai_clones',
  'video_ad_placements',
  'video_ad_metrics',
  'advertiser_discovery_records',
  'creator_video_ad_earnings',
  'ad_generation_jobs'
);

-- Expected output: 45+

-- Check views
SELECT table_name
FROM information_schema.views
WHERE table_schema = 'public'
AND table_name LIKE 'v_%';

-- Expected output: 4 views





Step 5: Verify Table Structure

SQL


-- Verify video_ad_campaigns table
\d video_ad_campaigns

-- Verify video_ad_creatives table
\d video_ad_creatives

-- Verify ai_clones table
\d ai_clones

-- Verify video_ad_placements table
\d video_ad_placements

-- Verify video_ad_metrics table
\d video_ad_metrics

-- Verify advertiser_discovery_records table
\d advertiser_discovery_records

-- Verify creator_video_ad_earnings table
\d creator_video_ad_earnings

-- Verify ad_generation_jobs table
\d ad_generation_jobs





Step 6: Test Data Insertion

SQL


-- Insert test advertiser campaign
INSERT INTO video_ad_campaigns (
  advertiser_id,
  campaign_name,
  campaign_description,
  product_name,
  product_url,
  budget,
  daily_budget,
  creator_share,
  status,
  start_date,
  end_date
) VALUES (
  1,
  'Test Campaign',
  'Sample campaign for testing',
  'Test Product',
  'https://example.com/product',
  10000.00,
  500.00,
  25.00,
  'draft',
  CURRENT_TIMESTAMP,
  CURRENT_TIMESTAMP + INTERVAL '30 days'
 ) RETURNING id;

-- Insert test creative
INSERT INTO video_ad_creatives (
  campaign_id,
  video_url,
  title,
  duration,
  generated_by
) VALUES (
  1,
  'https://example.com/video.mp4',
  'Test Creative',
  30,
  'user_uploaded'
 ) RETURNING id;

-- Insert test placement
INSERT INTO video_ad_placements (
  video_id,
  creator_id,
  campaign_id,
  creative_id,
  placement_type,
  placement_position,
  placement_duration
) VALUES (
  1,
  1,
  1,
  1,
  'pre_roll',
  0,
  5
) RETURNING id;

-- Query to verify data
SELECT * FROM video_ad_campaigns WHERE id = 1;
SELECT * FROM video_ad_creatives WHERE campaign_id = 1;
SELECT * FROM video_ad_placements WHERE campaign_id = 1;





Step 7: Update Your Backend Code

1. Add Drizzle Schema

In shared/schema.ts:

TypeScript


// Add at the end of the file
export {
  videoAdCampaigns,
  videoAdCreatives,
  aiClones,
  videoAdPlacements,
  videoAdMetrics,
  advertiserDiscoveryRecords,
  creatorVideoAdEarnings,
  adGenerationJobs,
} from './video-ads-schema';

export type {
  VideoAdCampaign,
  InsertVideoAdCampaign,
  VideoAdCreative,
  InsertVideoAdCreative,
  AIClone,
  InsertAIClone,
  VideoAdPlacement,
  InsertVideoAdPlacement,
  VideoAdMetric,
  InsertVideoAdMetric,
  AdvertiserDiscoveryRecord,
  InsertAdvertiserDiscoveryRecord,
  CreatorVideoAdEarning,
  InsertCreatorVideoAdEarning,
  AdGenerationJob,
  InsertAdGenerationJob,
} from './video-ads-schema';


2. Create Video Ads Services

Create server/services/video-ads.service.ts:

TypeScript


import { db } from '../storage';
import {
  videoAdCampaigns,
  videoAdCreatives,
  videoAdPlacements,
  creatorVideoAdEarnings,
} from '../../shared/schema';
import { eq, and } from 'drizzle-orm';

export class VideoAdsService {
  async createCampaign(data: any) {
    const result = await db.insert(videoAdCampaigns).values(data).returning();
    return result[0];
  }

  async getCampaign(id: number) {
    const result = await db
      .select()
      .from(videoAdCampaigns)
      .where(eq(videoAdCampaigns.id, id));
    return result[0];
  }

  async updateCampaign(id: number, data: any) {
    const result = await db
      .update(videoAdCampaigns)
      .set(data)
      .where(eq(videoAdCampaigns.id, id))
      .returning();
    return result[0];
  }

  async trackVideoAdView(placementId: number, creatorId: number) {
    // Implementation here
  }

  async getCreatorEarnings(creatorId: number) {
    const earnings = await db
      .select()
      .from(creatorVideoAdEarnings)
      .where(eq(creatorVideoAdEarnings.creatorId, creatorId));

    const total = earnings.reduce((sum, e) => sum + Number(e.totalEarnings), 0);
    return { total, earnings };
  }
}

export const videoAdsService = new VideoAdsService();


3. Add API Routes

In server/routes.ts:

TypeScript


import { videoAdsService } from './services/video-ads.service';

// Create campaign
app.post('/api/video-ads/campaigns', async (req, res) => {
  try {
    const campaign = await videoAdsService.createCampaign(req.body);
    res.json({ success: true, campaign });
  } catch (error) {
    res.status(500).json({ error: 'Failed to create campaign' });
  }
});

// Get campaign
app.get('/api/video-ads/campaigns/:id', async (req, res) => {
  try {
    const campaign = await videoAdsService.getCampaign(parseInt(req.params.id));
    res.json({ success: true, campaign });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get campaign' });
  }
});

// Get creator earnings
app.get('/api/video-ads/creator-earnings/:creatorId', async (req, res) => {
  try {
    const earnings = await videoAdsService.getCreatorEarnings(
      parseInt(req.params.creatorId)
    );
    res.json({ success: true, earnings });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get earnings' });
  }
});





Step 8: Run Tests

Bash


# Test database connection
npm run test:db

# Test API endpoints
npm run test:api

# Run full test suite
npm test





Step 9: Monitor Performance

SQL


-- Check table sizes
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname = 'public'
AND tablename IN (
  'video_ad_campaigns',
  'video_ad_creatives',
  'ai_clones',
  'video_ad_placements',
  'video_ad_metrics',
  'advertiser_discovery_records',
  'creator_video_ad_earnings',
  'ad_generation_jobs'
)
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- Check index usage
SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;





Step 10: Deploy to Production

Bash


# 1. Commit changes
git add .
git commit -m "Add video ads system with 8 new tables"

# 2. Push to Replit
git push origin main

# 3. Verify deployment
npm run build
npm start

# 4. Test endpoints
curl http://localhost:3000/api/video-ads/campaigns/1





Rollback Procedure (If Needed )

If you need to rollback the migration:

SQL


-- Drop all new tables (in reverse order of dependencies)
DROP TABLE IF EXISTS ad_generation_jobs CASCADE;
DROP TABLE IF EXISTS creator_video_ad_earnings CASCADE;
DROP TABLE IF EXISTS advertiser_discovery_records CASCADE;
DROP TABLE IF EXISTS video_ad_metrics CASCADE;
DROP TABLE IF EXISTS video_ad_placements CASCADE;
DROP TABLE IF EXISTS ai_clones CASCADE;
DROP TABLE IF EXISTS video_ad_creatives CASCADE;
DROP TABLE IF EXISTS video_ad_campaigns CASCADE;

-- Drop views
DROP VIEW IF EXISTS v_active_campaigns_metrics CASCADE;
DROP VIEW IF EXISTS v_creator_earnings_summary CASCADE;
DROP VIEW IF EXISTS v_campaign_performance_ranking CASCADE;
DROP VIEW IF EXISTS v_advertiser_discovery_pipeline CASCADE;

-- Drop stored procedures
DROP FUNCTION IF EXISTS calculate_daily_campaign_metrics CASCADE;
DROP FUNCTION IF EXISTS get_creator_total_earnings CASCADE;


Or restore from backup:

Bash


# Restore from backup file
psql $DATABASE_URL < profithackai_backup_YYYYMMDD_HHMMSS.sql





Troubleshooting

Issue: Foreign Key Constraint Error

Solution: Ensure users and videos tables exist before running migration.

SQL


-- Check if tables exist
SELECT table_name FROM information_schema.tables 
WHERE table_name IN ('users', 'videos');


Issue: Index Already Exists

Solution: The migration script uses CREATE INDEX IF NOT EXISTS, so this shouldn't occur. If it does:

SQL


-- Drop existing index
DROP INDEX IF EXISTS idx_video_ad_campaigns_advertiser_id;

-- Re-run migration


Issue: Trigger Function Already Exists

Solution: Use CREATE OR REPLACE FUNCTION (already in migration script).

Issue: Permission Denied

Solution: Ensure your database user has CREATE TABLE and CREATE INDEX permissions:

SQL


-- Grant permissions
GRANT CREATE ON DATABASE profithackai TO your_user;
GRANT USAGE ON SCHEMA public TO your_user;
GRANT CREATE ON SCHEMA public TO your_user;





Performance Optimization

After migration, optimize your database:

SQL


-- Analyze tables for query planner
ANALYZE video_ad_campaigns;
ANALYZE video_ad_creatives;
ANALYZE video_ad_placements;
ANALYZE video_ad_metrics;
ANALYZE advertiser_discovery_records;
ANALYZE creator_video_ad_earnings;
ANALYZE ad_generation_jobs;
ANALYZE ai_clones;

-- Vacuum to reclaim space
VACUUM FULL video_ad_campaigns;
VACUUM FULL video_ad_creatives;
VACUUM FULL video_ad_placements;
VACUUM FULL video_ad_metrics;
VACUUM FULL advertiser_discovery_records;
VACUUM FULL creator_video_ad_earnings;
VACUUM FULL ad_generation_jobs;
VACUUM FULL ai_clones;





Monitoring Queries

Use these queries to monitor your video ads system:

SQL


-- Daily revenue
SELECT
  DATE(created_at) as date,
  SUM(total_earnings) as total_earnings,
  COUNT(DISTINCT creator_id) as creators,
  COUNT(DISTINCT campaign_id) as campaigns
FROM creator_video_ad_earnings
GROUP BY DATE(created_at)
ORDER BY date DESC;

-- Top campaigns
SELECT
  c.campaign_name,
  COUNT(DISTINCT e.creator_id) as creators,
  SUM(e.total_earnings) as total_earnings,
  SUM(e.views) as total_views,
  SUM(e.clicks) as total_clicks
FROM video_ad_campaigns c
LEFT JOIN creator_video_ad_earnings e ON c.id = e.campaign_id
GROUP BY c.id, c.campaign_name
ORDER BY total_earnings DESC
LIMIT 10;

-- Top creators
SELECT
  creator_id,
  COUNT(DISTINCT campaign_id) as campaigns,
  SUM(total_earnings) as total_earnings,
  AVG(ctr) as avg_ctr
FROM creator_video_ad_earnings
GROUP BY creator_id
ORDER BY total_earnings DESC
LIMIT 10;





Success Checklist




Database backup created




Migration script executed successfully




All 8 tables created




All 45+ indexes created




All 4 views created




All 2 stored procedures created




All 8 triggers created




Test data inserted successfully




Verification queries passed




Backend services implemented




API routes added




Tests passed




Performance optimized




Deployed to production




Monitoring configured




Support

For issues or questions:

1.
Check the troubleshooting section above

2.
Review the migration script for syntax

3.
Check database logs: SELECT * FROM pg_stat_statements;

4.
Contact support with error messages and logs




Next Steps

After successful deployment:

1.
Implement AdvertiserDiscoveryBot service

2.
Implement AIViralAdGenerator service

3.
Implement VideoAdRevenueService

4.
Add frontend components for video ads

5.
Start recruiting advertisers

6.
Monitor metrics and optimize




Deployment Status: READY FOR PRODUCTION ✅

All tables, indexes, views, and procedures are production-ready and optimized for scale.

