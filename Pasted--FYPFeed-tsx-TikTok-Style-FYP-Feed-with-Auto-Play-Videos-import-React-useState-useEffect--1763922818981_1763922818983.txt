// FYPFeed.tsx - TikTok-Style FYP Feed with Auto-Play Videos

import React, { useState, useEffect, useRef, useCallback } from 'react';
import './FYPFeed.css';

interface Creator {
  id: string;
  name: string;
  handle: string;
  avatar: string;
  isFollowing?: boolean;
}

interface Video {
  id: string;
  title: string;
  description: string;
  videoUrl: string;
  thumbnail: string;
  creator: Creator;
  likes: number;
  comments: number;
  shares: number;
  views: number;
  duration: number;
  hashtags: string[];
}

interface FYPFeedProps {
  videos: Video[];
  onLoadMore?: () => void;
}

const FYPFeed: React.FC<FYPFeedProps> = ({ videos, onLoadMore }) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isMuted, setIsMuted] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const [likedVideos, setLikedVideos] = useState<Set<string>>(new Set());
  const videoRefs = useRef<(HTMLVideoElement | null)[]>([]);
  const containerRef = useRef<HTMLDivElement>(null);
  const intersectionObserverRef = useRef<IntersectionObserver | null>(null);

  // Initialize Intersection Observer for auto-play
  useEffect(() => {
    intersectionObserverRef.current = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const videoElement = entry.target as HTMLVideoElement;
          if (entry.isIntersecting) {
            // Video is in view - auto-play
            videoElement.play().catch((err) => {
              console.warn('Auto-play failed:', err);
            });
          } else {
            // Video is out of view - pause
            videoElement.pause();
            videoElement.currentTime = 0;
          }
        });
      },
      { threshold: 0.8 } // Trigger when 80% of video is visible
    );

    return () => {
      intersectionObserverRef.current?.disconnect();
    };
  }, []);

  // Observe video elements
  useEffect(() => {
    videoRefs.current.forEach((video) => {
      if (video && intersectionObserverRef.current) {
        intersectionObserverRef.current.observe(video);
      }
    });

    return () => {
      videoRefs.current.forEach((video) => {
        if (video && intersectionObserverRef.current) {
          intersectionObserverRef.current.unobserve(video);
        }
      });
    };
  }, [videos]);

  // Handle scroll to next video
  const handleScroll = useCallback((direction: 'up' | 'down') => {
    if (direction === 'down' && currentIndex < videos.length - 1) {
      setCurrentIndex(currentIndex + 1);
    } else if (direction === 'up' && currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }

    // Load more videos if near the end
    if (currentIndex >= videos.length - 3 && onLoadMore) {
      onLoadMore();
    }
  }, [currentIndex, videos.length, onLoadMore]);

  // Handle wheel scroll
  useEffect(() => {
    let scrollTimeout: NodeJS.Timeout;

    const handleWheel = (e: WheelEvent) => {
      e.preventDefault();
      clearTimeout(scrollTimeout);

      scrollTimeout = setTimeout(() => {
        if (e.deltaY > 0) {
          handleScroll('down');
        } else {
          handleScroll('up');
        }
      }, 100);
    };

    const container = containerRef.current;
    if (container) {
      container.addEventListener('wheel', handleWheel, { passive: false });
    }

    return () => {
      if (container) {
        container.removeEventListener('wheel', handleWheel);
      }
      clearTimeout(scrollTimeout);
    };
  }, [handleScroll]);

  // Handle keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'ArrowDown') {
        handleScroll('down');
      } else if (e.key === 'ArrowUp') {
        handleScroll('up');
      } else if (e.key === ' ') {
        e.preventDefault();
        const currentVideo = videoRefs.current[currentIndex];
        if (currentVideo) {
          if (currentVideo.paused) {
            currentVideo.play();
          } else {
            currentVideo.pause();
          }
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [currentIndex, handleScroll]);

  // Handle touch swipe
  const touchStartY = useRef(0);
  const handleTouchStart = (e: React.TouchEvent) => {
    touchStartY.current = e.touches[0].clientY;
  };

  const handleTouchEnd = (e: React.TouchEvent) => {
    const touchEndY = e.changedTouches[0].clientY;
    const diff = touchStartY.current - touchEndY;

    if (Math.abs(diff) > 50) {
      if (diff > 0) {
        handleScroll('down');
      } else {
        handleScroll('up');
      }
    }
  };

  // Toggle like
  const toggleLike = (videoId: string) => {
    setLikedVideos((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(videoId)) {
        newSet.delete(videoId);
      } else {
        newSet.add(videoId);
      }
      return newSet;
    });
  };

  // Format numbers (1.2K, 1.5M, etc.)
  const formatNumber = (num: number): string => {
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
  };

  // Format duration (MM:SS)
  const formatDuration = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  if (!videos || videos.length === 0) {
    return (
      <div className="fyp-feed-empty">
        <p>No videos available</p>
      </div>
    );
  }

  const currentVideo = videos[currentIndex];

  return (
    <div
      className="fyp-feed-container"
      ref={containerRef}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
    >
      {/* Video Container */}
      <div className="fyp-video-wrapper">
        <video
          ref={(el) => {
            videoRefs.current[currentIndex] = el;
          }}
          className="fyp-video"
          poster={currentVideo.thumbnail}
          muted={isMuted}
          loop
          playsInline
        >
          <source src={currentVideo.videoUrl} type="video/mp4" />
          Your browser does not support the video tag.
        </video>

        {/* Video Overlay Gradient */}
        <div className="fyp-video-overlay"></div>

        {/* Mute/Unmute Button (Top Right) */}
        <button
          className="fyp-mute-btn"
          onClick={() => setIsMuted(!isMuted)}
          title={isMuted ? 'Unmute' : 'Mute'}
        >
          {isMuted ? (
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M13.5 4.06c0-1.336-1.616-2.256-2.73-1.72l-5.24 3.02C5.1 5.95 4 7.12 4 8.5v7c0 1.38 1.1 2.55 2.53 2.94l5.24 3.02c1.11.536 2.73-.384 2.73-1.72V4.06zM15.4 12c0-1.81 1.56-3.3 3.5-3.3s3.5 1.49 3.5 3.3-1.56 3.3-3.5 3.3-3.5-1.49-3.5-3.3z" />
            </svg>
          ) : (
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" />
            </svg>
          )}
        </button>

        {/* Video Info (Bottom Left) */}
        <div className="fyp-video-info">
          <div className="fyp-creator-info">
            <img
              src={currentVideo.creator.avatar}
              alt={currentVideo.creator.name}
              className="fyp-creator-avatar"
            />
            <div className="fyp-creator-details">
              <p className="fyp-creator-name">{currentVideo.creator.name}</p>
              <p className="fyp-creator-handle">@{currentVideo.creator.handle}</p>
            </div>
            <button className="fyp-follow-btn">
              {currentVideo.creator.isFollowing ? 'Following' : 'Follow'}
            </button>
          </div>

          <p className="fyp-video-title">{currentVideo.title}</p>
          <p className="fyp-video-description">{currentVideo.description}</p>

          {currentVideo.hashtags.length > 0 && (
            <div className="fyp-hashtags">
              {currentVideo.hashtags.map((tag) => (
                <span key={tag} className="fyp-hashtag">
                  #{tag}
                </span>
              ))}
            </div>
          )}
        </div>

        {/* Sound Icon (Bottom Left Corner) */}
        <div className="fyp-sound-badge">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z" />
          </svg>
          <span>Original Sound</span>
        </div>
      </div>

      {/* Right Sidebar - Actions */}
      <div className="fyp-actions-sidebar">
        {/* Like Button */}
        <button
          className={`fyp-action-btn fyp-like-btn ${
            likedVideos.has(currentVideo.id) ? 'liked' : ''
          }`}
          onClick={() => toggleLike(currentVideo.id)}
        >
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" />
          </svg>
          <span>{formatNumber(currentVideo.likes)}</span>
        </button>

        {/* Comment Button */}
        <button className="fyp-action-btn fyp-comment-btn">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z" />
          </svg>
          <span>{formatNumber(currentVideo.comments)}</span>
        </button>

        {/* Share Button */}
        <button className="fyp-action-btn fyp-share-btn">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.15c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.44 9.31 6.77 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.77 0 1.44-.3 1.96-.77l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z" />
          </svg>
          <span>{formatNumber(currentVideo.shares)}</span>
        </button>

        {/* Bookmark Button */}
        <button className="fyp-action-btn fyp-bookmark-btn">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M17 3H5c-1.11 0-2 .9-2 2v16l7-3 7 3V5c0-1.1.89-2 2-2z" />
          </svg>
        </button>
      </div>

      {/* Loading Indicator */}
      {isLoading && <div className="fyp-loading">Loading...</div>}

      {/* Scroll Indicator */}
      <div className="fyp-scroll-indicator">
        {currentIndex + 1} / {videos.length}
      </div>
    </div>
  );
};

export default FYPFeed;